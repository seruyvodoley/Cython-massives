"""бинарный поиск
Инициализация: Алгоритм начинается с отсортированного массива данных. Такой массив упорядочен, что элементы либо
увеличиваются, либо убывают (обычно по возрастанию).

Установка границ: Алгоритм устанавливает две границы для диапазона поиска. Первоначально это начало и конец массива.

Вычисление среднего элемента: Алгоритм вычисляет средний элемент в текущем диапазоне поиска, находя его индекс как
среднее арифметическое от индексов начала и конца диапазона.

Сравнение среднего элемента с ключом: Алгоритм сравнивает средний элемент с ключом, который нужно найти. В зависимости
от результата сравнения возможны три случая:

Если средний элемент равен ключу, то поиск завершен, и возвращается индекс среднего элемента.
Если средний элемент больше ключа, то алгоритм сужает диапазон поиска, устанавливая новую правую границу включительно
до текущего среднего элемента. Поиск продолжается в левой половине диапазона.
Если средний элемент меньше ключа, то алгоритм сужает диапазон поиска, устанавливая новую левую границу начиная с
элемента, следующего за текущим средним элементом. Поиск продолжается в правой половине диапазона.
Повторение: Алгоритм повторяет шаги 3-4 до тех пор, пока диапазон поиска не станет пустым (левая граница больше правой)
или до тех пор, пока элемент не будет найден.

Результат: Если элемент найден, алгоритм возвращает его индекс; если элемент не найден, то обычно возвращается
7специальное значение, такое как -1 или None, чтобы обозначить, что элемент отсутствует в массиве."""


def binary(array, key):
    """
    функция бинарного поиска
    :param key: элемент для поиска
    :type key: int/double
    :param array: массив для поиска
    :type array: dynamic_array_c.array
    :return right_side: результат
    :rtype: int
    """
    if not array:
        return None  # если для 0 или нет массива
    left_side = -1  # левая граница поиска
    right_side = len(array)  # правая граница поиска
    while right_side > left_side + 1:  # пока в диапазоне больше одного элемента
        middle = (left_side + right_side) // 2  # берем средний индекс
        if array[middle] >= key:
            right_side = middle
        else:
            left_side = middle
    if key > array[array.length - 1] or key < array[0]:
        return None  # если ключ за пределами массива или его там нет
    return right_side
